---
title: "p8105_hw3_tp2859"
author: "Tingcheng Pan"
date: "2024-10-12"
output: html_document
---

```{r}
library(p8105.datasets)
library(tidyverse)
data("ny_noaa")
data <- ny_noaa
```

```{r}
data <- data %>%
  mutate(date = as.Date(date),
         year = lubridate::year(date),
         month = lubridate::month(date),
         day = lubridate::day(date))
```

#Problem1
```{r}
# Convert units (assuming tenths of mm for prcp, snow, snwd and tenths of degrees for tmax, tmin)
data <- data %>%
  mutate(
    prcp = as.numeric(prcp) / 10,  # Convert to mm
    snow = as.numeric(snow) / 10,  # Convert to mm
    snwd = as.numeric(snwd) / 10,  # Convert to mm
    tmax = as.numeric(tmax) / 10,  # Convert to degrees Celsius
    tmin = as.numeric(tmin) / 10  # Convert to degrees Celsius
  )

# Summary of most common snowfall values
snowfall_counts <- data %>% 
  count(snow, sort = TRUE)
print(snowfall_counts)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

```{r}
# Summary of most common snowfall values
snowfall_counts <- data %>% 
  count(snow, sort = TRUE)
print(snowfall_counts)

# Average max temperature in January and July across years
january_data <- data %>% filter(month == 1)
july_data <- data %>% filter(month == 7)

avg_max_temp_january <- january_data %>% group_by(id, year) %>% summarise(avg_tmax = mean(tmax, na.rm = TRUE), .groups = 'drop')
avg_max_temp_july <- july_data %>% group_by(id, year) %>% summarise(avg_tmax = mean(tmax, na.rm = TRUE), .groups = 'drop')

```


```{r}
# Plotting average max temperature in January and July
par(mfrow = c(1, 2))

plot(avg_max_temp_january$year, avg_max_temp_january$avg_tmax, type = 'b', col = 'blue',
     main = 'Average Max Temperature in January', xlab = 'Year', ylab = 'Temperature (째C)')

plot(avg_max_temp_july$year, avg_max_temp_july$avg_tmax, type = 'b', col = 'red',
     main = 'Average Max Temperature in July', xlab = 'Year', ylab = 'Temperature (째C)')
# Tmax vs Tmin and snowfall distribution
par(mfrow = c(1, 2))

# Hexbin-like scatterplot for tmax vs tmin
data_filtered <- data %>% filter(!is.na(tmax) & !is.na(tmin))
dens <- MASS::kde2d(data_filtered$tmax, data_filtered$tmin, n = 50)
image(dens, col = topo.colors(50), main = 'Tmax vs Tmin', xlab = 'Max Temperature (째C)', ylab = 'Min Temperature (째C)')


# Distribution of snowfall > 0 and < 100 by year
snowfall_filtered <- data %>% filter(snow > 0 & snow < 100)

hist(snowfall_filtered$year, breaks = length(unique(snowfall_filtered$year)),
     main = 'Distribution of Snowfall (0 < Snowfall < 100 mm) by Year',
     xlab = 'Year', ylab = 'Frequency', col = 'lightblue')
```
#Problem2
```{r}
library(dplyr)
library(ggplot2)
library(tidyr)

# Load datasets
nhanes_covar <- read.csv("nhanes_covar.csv",skip = 4)
nhanes_accel <- read.csv("nhanes_accel.csv")
```

```{r}
# Filter out participants less than 21 years of age and those with missing demographic data
nhanes_covar <- nhanes_covar %>%
  filter(age >= 21) %>%
  drop_na()

# Merge accelerometer and covariate data by SEQN
nhanes_data <- merge(nhanes_accel, nhanes_covar, by = "SEQN")

# Encode categorical variables
nhanes_data$sex <- factor(nhanes_data$sex, levels = c(1, 2), labels = c("Male", "Female"))
nhanes_data$education <- factor(nhanes_data$education, levels = c(1, 2, 3), 
                                labels = c("Less than high school", "High school equivalent", "More than high school"))

# Produce a table for the number of men and women in each education category
education_sex_table <- nhanes_data %>%
  group_by(sex, education) %>%
  summarise(count = n()) %>%
  ungroup()
print(education_sex_table)
```

```{r}
# Create a visualization of the age distributions for men and women in each education category
ggplot(nhanes_data, aes(x = age, fill = sex)) +
  geom_histogram(binwidth = 5, position = "dodge", color = "black") +
  facet_wrap(~ education) +
  labs(title = "Age Distribution by Sex and Education Level", x = "Age", y = "Count") +
  theme_minimal()

# Aggregate accelerometer data across minutes to create a total activity variable for each participant
nhanes_data <- nhanes_data %>%
  mutate(total_activity = rowSums(select(., starts_with("min")), na.rm = TRUE))

# Plot total activities against age, comparing men to women with separate panels for each education level
ggplot(nhanes_data, aes(x = age, y = total_activity, color = sex)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "loess") +
  facet_wrap(~ education) +
  labs(title = "Total Activity vs Age by Sex and Education Level", x = "Age", y = "Total Activity") +
  theme_minimal()

# Create a three-panel plot showing 24-hour activity time courses for each education level
nhanes_long <- nhanes_data %>%
  pivot_longer(cols = starts_with("min"), names_to = "minute", values_to = "activity") %>%
  mutate(minute = as.numeric(gsub("min", "", minute)))

ggplot(nhanes_long, aes(x = minute, y = activity, color = sex)) +
  geom_line(stat = "summary", fun = "mean") +
  facet_wrap(~ education) +
  labs(title = "24-Hour Activity Time Courses by Education Level", x = "Minute of the Day", y = "Average Activity") +
  theme_minimal()
```
#Problem3
```{r}
# Load the datasets
jan_2020 <- read.csv("citibike/Jan 2020 Citi.csv")
jan_2024 <- read.csv("citibike/Jan 2024 Citi.csv")
july_2020 <- read.csv("citibike/July 2020 Citi.csv")
july_2024 <- read.csv("citibike/July 2024 Citi.csv")

# Combine all data into one dataframe
data <- bind_rows(
  jan_2020 %>% mutate(month = "January", year = 2020),
  jan_2024 %>% mutate(month = "January", year = 2024),
  july_2020 %>% mutate(month = "July", year = 2020),
  july_2024 %>% mutate(month = "July", year = 2024)
)

# Clean and tidy the dataset
data_clean <- data %>%
  mutate(
    member_casual = tolower(member_casual),
    weekdays = factor(weekdays, levels = c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")),
    duration = as.numeric(duration)
  )

# 1. Create a table showing the total number of rides in each combination of year and month separating casual riders and members
ride_summary <- data_clean %>%
  group_by(year, month, member_casual) %>%
  summarise(total_rides = n(), .groups = 'drop') %>%
  pivot_wider(names_from = member_casual, values_from = total_rides, values_fill = 0)

print("Table: Total number of rides by year, month, and membership status")
print(ride_summary)

```

```{r}
# 2. Table showing the 5 most popular starting stations for July 2024
july_2024_stations <- data_clean %>%
  filter(year == 2024 & month == "July") %>%
  group_by(start_station_name) %>%
  summarise(total_rides = n()) %>%
  arrange(desc(total_rides)) %>%
  head(5)

print("Table: 5 most popular starting stations in July 2024")
print(july_2024_stations)
```

```{r}
# 3. Plot to investigate effects of day of the week, month, and year on median ride duration
median_duration_plot <- data_clean %>%
  group_by(year, month, weekdays) %>%
  summarise(median_duration = median(duration, na.rm = TRUE), .groups = 'drop') %>%
  ggplot(aes(x = weekdays, y = median_duration, fill = interaction(year, month))) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Median Ride Duration by Day of the Week, Month, and Year", x = "Day of the Week", y = "Median Duration (minutes)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

print(median_duration_plot)
```

```{r}
# 4. Plot to show the impact of month, membership status, and bike type on the distribution of ride duration (2024 data)
duration_distribution_plot <- data_clean %>%
  filter(year == 2024) %>%
  ggplot(aes(x = duration, fill = interaction(member_casual, rideable_type))) +
  geom_histogram(bins = 30, position = "dodge") +
  facet_wrap(~month) +
  labs(title = "Ride Duration Distribution by Month, Membership Status, and Bike Type (2024)", x = "Duration (minutes)", y = "Count") +
  theme_minimal()

print(duration_distribution_plot)
# Comments on the results:
# - From the ride summary, we can see a general trend of increasing rides in 2024 compared to 2020, which could indicate a growth in the popularity of the Citi Bike program.
# - The most popular starting stations in July 2024 suggest high demand in certain areas, possibly due to their proximity to popular destinations.
# - The median ride duration plot shows differences based on day of the week, month, and year, highlighting peak ride days and potential usage patterns, such as longer durations on weekends.
# - The distribution of ride durations for 2024 shows variations based on membership and bike type, with casual riders and electric bikes generally showing longer ride times, indicating different usage behavior compared to members using classic bikes.
```

